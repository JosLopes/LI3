/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  q04.c
 * @brief Implementation of methods in include/queries/q04.h
 */

#include <stdio.h>

#include "queries/q04.h"
#include "queries/query_instance.h"
#include "utils/glib/GConstKeyHashTable.h"
#include "utils/glib/GConstPtrArray.h"

/**
 * @brief   Parses the arguments of a query of type 4.
 * @details Asserts that there's only one argument, a hotel identifier.
 *
 * @param argc Number of arguments.
 * @param argv Values of the arguments.
 *
 * @return `NULL` on parsing failure, a ::hotel_id_t encoded as a pointer otherwise.
 */
void *__q04_parse_arguments(size_t argc, char *const argv[argc]) {
    if (argc != 1)
        return NULL;

    hotel_id_t id;
    return hotel_id_from_string(&id, argv[0]) ? NULL : GUINT_TO_POINTER(id);
}

/**
 * @brief  Creates a deep clone of the value returned by ::__q04_parse_arguments.
 * @param  args_data Non-`NULL` value returned by ::__q04_parse_arguments (a hotel's identifier
 *         encoded as a pointer).
 * @return A deep copy of @p args_data.
 */
void *__q04_clone_arguments(const void *args_data) {
    return (void *) args_data; /* Const cast acceptable - it's an just an integer */
}

/**
 * @brief   Frees data generated by ::__q04_parse_arguments.
 * @details Does nothing, as @p args_data is just an integer encoded as a pointer.
 * @param   args_data Data generated by ::__q04_parse_arguments.
 */
void __q04_free_arguments(void *args_data) {
    (void) args_data;
}

/**
 * @brief   Callback for every reservation in the database, that adds it to its corresponding hotel
 *          in @p user_data.
 * @details Auxiliary method for ::__q04_generate_statistics.
 *
 * @param user_data   A ::GConstKeyHashTable that associates hotel identifiers (integers) to arrays
 *                    (::GConstPtrArray) of pointers to reservations (::reservation_t).
 * @param reservation A ::reservation_t in the database.
 *
 * @retval 0 Always successful.
 */
int __q04_generate_statistics_foreach_reservation(void                *user_data,
                                                  const reservation_t *reservation) {

    const hotel_id_t      hotel_id     = reservation_get_hotel_id(reservation);
    GConstPtrArray *const reservations = g_hash_table_lookup(user_data, GUINT_TO_POINTER(hotel_id));
    if (!reservations)
        return 0;

    g_const_ptr_array_add(reservations, reservation);
    return 0;
}

/**
 * @brief   A comparison function for sorting a ::GConstPtrArray of reservations.
 * @details Auxiliary method for ::__q04_generate_statistics_sort_each_array, itself an
 *          auxiliary method for ::__q04_generate_statistics.
 */
gint __q04_sort_reservations_by_date(const void *const *a, const void *const *b) {
    const reservation_t *const reservation_a = *((const reservation_t *const *) a);
    const reservation_t *const reservation_b = *((const reservation_t *const *) b);

    const int64_t crit1 = date_diff(reservation_get_begin_date(reservation_b),
                                    reservation_get_begin_date(reservation_a));
    if (crit1)
        return crit1;

    const int64_t crit2 = reservation_get_id(reservation_a) - reservation_get_id(reservation_b);
    return crit2;
}

/**
 * @brief Sorts each array of reservations in the statistical's data hash table.
 *
 * @param hotel Hotel identifier encoded as a pointer.
 * @param list  Array of reservations to be sorted (::GConstPtrArray).
 * @param data  External data (not used).
 */
void __q04_generate_statistics_sort_each_array(gconstpointer hotel, gpointer list, gpointer data) {
    (void) hotel;
    (void) data;
    g_const_ptr_array_sort(list, __q04_sort_reservations_by_date);
}

/**
 * @brief Generates statistical data for queries of type 4.
 *
 * @param database   Database, to iterate through reservations.
 * @param n          Number of query instances that need to be executed.
 * @param instances  Query instances that need to be executed.
 *
 * @return A ::GConstKeyHashTable associating hotel identifiers (integers) to arrays
 *         (::GConstPtrArray) of reservations (::reservation_t).
 */
void *__q04_generate_statistics(const database_t             *database,
                                size_t                        n,
                                const query_instance_t *const instances[n]) {

    GConstKeyHashTable *const hotel_reservations =
        g_const_key_hash_table_new_full(g_direct_hash,
                                        g_direct_equal,
                                        (GDestroyNotify) g_const_ptr_array_unref);
    for (size_t i = 0; i < n; ++i)
        g_const_key_hash_table_insert(hotel_reservations,
                                      query_instance_get_argument_data(instances[i]), /* hotel id */
                                      g_const_ptr_array_new());

    reservation_manager_iter(database_get_reservations(database),
                             __q04_generate_statistics_foreach_reservation,
                             hotel_reservations);

    g_const_key_hash_table_foreach(hotel_reservations,
                                   __q04_generate_statistics_sort_each_array,
                                   NULL);
    return hotel_reservations;
}

/**
 * @brief Method called to execute a query of type 4.
 *
 * @param database   Database to get data from (not used, as all data is collected in
 *                   ::__q04_generate_statistics).
 * @param statistics Statistical data generated by ::__q04_generate_statistics (a
 *                   ::GConstKeyHashTable that associates identifiers of hotels (integers) to
 *                   arrays (::GConstPtrArray) of reservations (::reservation_t)).
 * @param instance   Query instance to be executed.
 * @param output     Where to write the query's result to.
 *
 * @retval 0 Success.
 * @retval 1 Fatal failure (should, in principle, be unreachable).
 */
int __q04_execute(const database_t       *database,
                  const void             *statistics,
                  const query_instance_t *instance,
                  query_writer_t         *output) {
    (void) database;

    const hotel_id_t hotel_id = GPOINTER_TO_UINT(query_instance_get_argument_data(instance));
    const GConstPtrArray *const reservations =
        g_const_key_hash_table_const_lookup(statistics, GUINT_TO_POINTER(hotel_id));
    if (!reservations) {
        fprintf(stderr, "Bad statistical data in query 4! This should not happen!\n");
        return 1; /* Only happens on bad statistics, which itself shouldn't happen. */
    }

    const size_t reservations_len = g_const_ptr_array_get_length(reservations);
    for (size_t i = 0; i < reservations_len; i++) {
        const reservation_t *const reservation = g_const_ptr_array_index(reservations, i);

        const char *const user_id     = reservation_get_const_user_id(reservation);
        const uint8_t     rating      = reservation_get_rating(reservation);
        const double      total_price = reservation_calculate_price(reservation);

        char begin_date_str[DATE_SPRINTF_MIN_BUFFER_SIZE];
        char end_date_str[DATE_SPRINTF_MIN_BUFFER_SIZE];
        char reservation_id_str[RESERVATION_ID_SPRINTF_MIN_BUFFER_SIZE];
        date_sprintf(begin_date_str, reservation_get_begin_date(reservation));
        date_sprintf(end_date_str, reservation_get_end_date(reservation));
        reservation_id_sprintf(reservation_id_str, reservation_get_id(reservation));

        query_writer_write_new_object(output);
        query_writer_write_new_field(output, "id", "%s", reservation_id_str);
        query_writer_write_new_field(output, "begin_date", "%s", begin_date_str);
        query_writer_write_new_field(output, "end_date", "%s", end_date_str);
        query_writer_write_new_field(output, "user_id", "%s", user_id);
        query_writer_write_new_field(output, "rating", "%" PRIu8, rating);
        query_writer_write_new_field(output, "total_price", "%.3lf", total_price);
    }

    return 0;
}

query_type_t *q04_create(void) {
    return query_type_create(4,
                             __q04_parse_arguments,
                             __q04_clone_arguments,
                             __q04_free_arguments,
                             __q04_generate_statistics,
                             (query_type_free_statistics_callback_t) g_hash_table_unref,
                             __q04_execute);
}
