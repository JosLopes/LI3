/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  q07.c
 * @brief Implementation of methods in include/queries/q07.h
 */

#include <glib.h>
#include <math.h>

#include "queries/q07.h"
#include "queries/query_instance.h"
#include "utils/int_utils.h"

/**
 * @brief   Parses the arguments of a query of type 7.
 * @details Asserts there's only one integer argument..
 *
 * @param argc Number of arguments.
 * @param argv Values of the arguments.
 *
 * @return `NULL` for invalid arguments, an integer encoded as a pointer otherwise.
 */
void *__q07_parse_arguments(size_t argc, char *const argv[argc]) {
    if (argc != 1)
        return NULL;

    /* Parse number of flights */
    uint64_t  n;
    const int retval = int_utils_parse_positive(&n, argv[0]);
    if (retval)
        return NULL; /* Invalid N format */

    return GUINT_TO_POINTER(n);
}

/**
 * @brief  Creates a deep clone of the value returned by ::__q07_parse_arguments.
 * @param  args_data Non-`NULL` value returned by ::__q07_parse_arguments (an integer encoded as a
 *                   pointer).
 * @return A deep copy of @p args_data.
 */
void *__q07_clone_arguments(const void *args_data) {
    return (void *) args_data; /* Const cast acceptable - it's an just an integer */
}

/**
 * @brief   Frees data generated by ::__q07_parse_arguments.
 * @details Does nothing, as @p args_data is just an integer encoded as a pointer.
 * @param   args_data Data generated by ::__q07_parse_arguments.
 */
void __q07_free_arguments(void *args_data) {
    (void) args_data;
}

/**
 * @brief   A comparison function for sorting an `GArray` of `int64_t`s.
 * @details Auxiliary method for ::__q07_generate_statistics.
 */
gint __q07_generate_statistics_int64_compare_func(gconstpointer a, gconstpointer b) {
    return *(const int64_t *) a - *(const int64_t *) b;
}

/**
 * @brief Function called for every flight, that adds it to an array of flights associated with an
 *        airport.
 *
 * @param user_data A `GHashTable` that associates ::airport_code_t's to `GArray`s of delays
 *                  (`int64_t`),
 * @param flight    Flight to be processed.
 *
 * @retval 0 Always. Don't stop iteration.
 */
int __q07_generate_statistics_foreach_flight(void *user_data, const flight_t *flight) {
    GHashTable *const airport_delays = user_data;

    const airport_code_t airport_code = flight_get_origin(flight);
    const int64_t        delay        = date_and_time_diff(flight_get_real_departure_date(flight),
                                             flight_get_schedule_departure_date(flight));

    GArray *delays = g_hash_table_lookup(airport_delays, GUINT_TO_POINTER(airport_code));
    if (!delays) {
        delays = g_array_new(FALSE, FALSE, sizeof(int64_t));
        g_hash_table_insert(airport_delays, GUINT_TO_POINTER(airport_code), delays);
    }

    g_array_append_val(delays, delay);
    return 0;
}

/**
 * @struct q07_airport_median
 * @brief  Pair composed of an airport and its departure delay median.
 *
 * @var q07_airport_median::airport_code
 *     @brief Airport to whom ::q07_airport_median::median applies.
 * @var q07_airport_median::median
 *     @brief Departure delay median of q07_airport_median::airport_code.
 */
typedef struct {
    airport_code_t airport_code;
    int64_t        median;
} q07_airport_median;

/**
 * @brief Function called for every airport, to generate an array of ::q07_airport_median.
 *
 * @param key       An `airport_code_t` as a pointer.
 * @param value     A pointer to a `GArray` of `int64_t`, the delays of all flights in seconds.
 * @param user_data A `GArray` of ::q07_airport_median to which a new value will be added.
 */
void __q07_generate_statistics_foreach_airport(gpointer key, gpointer value, gpointer user_data) {
    const airport_code_t airport = GPOINTER_TO_UINT(key);
    GArray *const        delays  = value;
    GArray *const        to_add  = user_data;

    g_array_sort(delays, __q07_generate_statistics_int64_compare_func);

    double median;
    if (delays->len % 2 == 0) {
        const size_t middle = delays->len / 2;
        median              = (g_array_index(delays, uint64_t, middle) +
                  g_array_index(delays, uint64_t, middle - 1)) *
                 0.5;
    } else {
        median = g_array_index(delays, uint64_t, delays->len / 2);
    }

    const q07_airport_median airport_median = {.airport_code = airport, .median = round(median)};
    g_array_append_val(to_add, airport_median);
}

/**
 * @brief   Comparsion criteria for sorting arrays of ::q07_airport_median.
 * @details Auxiliary method for ::__q07_generate_statistics.
 *
 * @param a Pointer to a `const` ::q07_airport_median.
 * @param b Pointer to a `const` ::q07_airport_median.
 *
 * @return Comparison value between @p a and @p b.
 */
gint __q07_generate_statistics_airport_median_compare_func(gconstpointer a, gconstpointer b) {
    const q07_airport_median *const airport_median_a = a;
    const q07_airport_median *const airport_median_b = b;

    const uint64_t crit1 = airport_median_b->median - airport_median_a->median;
    if (crit1)
        return crit1;

    char airport_code_a_str[AIRPORT_CODE_SPRINTF_MIN_BUFFER_SIZE];
    char airport_code_b_str[AIRPORT_CODE_SPRINTF_MIN_BUFFER_SIZE];
    airport_code_sprintf(airport_code_a_str, airport_median_a->airport_code);
    airport_code_sprintf(airport_code_b_str, airport_median_b->airport_code);

    return strcmp(airport_code_a_str, airport_code_b_str);
}

/**
 * @brief Generates statistical data for queries of type 7.
 *
 * @param database  Database, to iterate through flights.
 * @param n         Number of query instances that will need to be executed.
 * @param instances Query instances that will need to be executed.
 *
 * @return A sorted `GArray` of ::q07_airport_median.
 */
void *__q07_generate_statistics(const database_t             *database,
                                size_t                        n,
                                const query_instance_t *const instances[n]) {
    (void) instances;
    (void) n;

    /* Associate each airport with list of delays */
    GHashTable *const airport_delays =
        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) g_array_unref);
    flight_manager_iter(database_get_flights(database),
                        __q07_generate_statistics_foreach_flight,
                        airport_delays);

    /* Calulate sorted array of airports with delays */
    GArray *const airport_medians = g_array_new(FALSE, FALSE, sizeof(q07_airport_median));
    g_hash_table_foreach(airport_delays,
                         __q07_generate_statistics_foreach_airport,
                         airport_medians);
    g_array_sort(airport_medians, __q07_generate_statistics_airport_median_compare_func);

    g_hash_table_unref(airport_delays);
    return airport_medians;
}

/**
 * @brief Executes a query of type 7.
 *
 * @param database   Database to get data from (not used, as all data is collected in
 *                   ::__q07_generate_statistics).
 * @param statistics Value returned by ::__q07_generate_statistics (a sorted `GArray` of
 *                   ::q07_airport_median.)
 * @param instance   Query instance to be executed.
 * @param output     Where to write the query's output to.
 *
 * @retval 0 Always successful.
 */
int __q07_execute(const database_t       *database,
                  const void             *statistics,
                  const query_instance_t *instance,
                  query_writer_t         *output) {
    (void) database;

    const uint64_t      n = GPOINTER_TO_UINT(query_instance_get_argument_data(instance));
    const GArray *const airport_medians = statistics;

    const size_t i_max = min(n, airport_medians->len);
    for (size_t i = 0; i < i_max; i++) {
        const q07_airport_median *const airport_median =
            &g_array_index(airport_medians, q07_airport_median, i);

        char airport_code_str[AIRPORT_CODE_SPRINTF_MIN_BUFFER_SIZE];
        airport_code_sprintf(airport_code_str, airport_median->airport_code);

        query_writer_write_new_object(output);
        query_writer_write_new_field(output, "name", "%s", airport_code_str);
        query_writer_write_new_field(output, "median", "%" PRIu64, airport_median->median);
    }
    return 0;
}

query_type_t *q07_create(void) {
    return query_type_create(7,
                             __q07_parse_arguments,
                             __q07_clone_arguments,
                             __q07_free_arguments,
                             __q07_generate_statistics,
                             (query_type_free_statistics_callback_t) g_array_unref,
                             __q07_execute);
}
