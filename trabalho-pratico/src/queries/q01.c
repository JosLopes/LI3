/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  q01.c
 * @brief Implementation of methods in include/queries/q01.h
 */

#include <stdio.h>
#include <stdlib.h>

#include "queries/q01.h"
#include "queries/query_instance.h"
#include "utils/int_utils.h"
#include "utils/single_pool_id_linked_list.h"

typedef enum {
    ID_ENTITY_USER,
    ID_ENTITY_FLIGHT,
    ID_ENTITY_RESERVATION
} id_entity_t;

/**
 * @struct parse_arguments_helper_t
 * @brief  Data needed for the execution of a query of type 1.
 *
 * @var parse_arguments_helper::id_entity
 *     @brief Stores the entity of an identifier.
 * @var parse_arguments_helper::parsed_id
 *     @brief A pointer to an id, of type `char *` or `uint64_t *`.
 */
typedef struct {
    id_entity_t id_entity;
    void       *parsed_id;
} parse_arguments_helper_t;

/**
 * @brief   Parses the arguments of a query of type 1.
 * @details Asserts there's only one string argument, that is stored.
 *
 * @param argv Values of the arguments.
 * @param argc Number of arguments.
 *
 * @return `NULL` for invalid arguments, a copy of the only @p argv and its identifier on success.
 */
void *__q01_parse_arguments(char **argv, size_t argc) {
    if (argc != 1 || !(**argv))
        return NULL;

    size_t                    parsed_id_aux;
    size_t                    length          = strlen(*argv);
    parse_arguments_helper_t *parsed_argument = malloc(sizeof(parse_arguments_helper_t));
    if (!parsed_argument)
        return NULL;

    if (!int_utils_parse_positive(&parsed_id_aux, *argv)) {
        uint64_t *parsed_id = malloc(sizeof(uint64_t));
        if (!parsed_id)
            return parsed_id;

        *parsed_id                 = parsed_id_aux;
        parsed_argument->id_entity = ID_ENTITY_FLIGHT;
        parsed_argument->parsed_id = parsed_id;
    } else if (length > 4 /* skip "BOOK" in reservation id */
               && !int_utils_parse_positive(&parsed_id_aux, *argv + 4)) {
        uint64_t *parsed_id = malloc(sizeof(uint64_t));
        if (!parsed_id)
            return parsed_id;

        *parsed_id                 = parsed_id_aux;
        parsed_argument->id_entity = ID_ENTITY_RESERVATION;
        parsed_argument->parsed_id = parsed_id;
    } else {
        char *parsed_id = strdup(*argv);
        if (!parsed_id)
            return parsed_id;

        parsed_argument->id_entity = ID_ENTITY_USER;
        parsed_argument->parsed_id = parsed_id;
    }

    return parsed_argument;
}

/**
 * @brief Frees data generated by ::__q01_parse_arguments.
 * @param argument_data Data generated by ::__q01_parse_arguments.
 */
void __q01_free_query_instance_argument_data(void *argument_data) {
    free(((parse_arguments_helper_t *) argument_data)->parsed_id);
    free(argument_data);
}

/**
 * @brief   Calculates the total spent by a ::user_t.
 * @details The total spent is the sum of the total price of all the reservations the user is
 *          related to.
 *
 * @param list    List to get the reservation identifiers from.
 * @param manager Manager to get the reservations from.
 *
 * @return The total spent by a ::user_t.
 */
double __user_total_spent(single_pool_id_linked_list_t *list, reservation_manager_t *manager) {
    reservation_t *reservation;
    date_t         begin_date;
    date_t         end_date;
    double         total_spent = 0;
    uint64_t       price_per_night;
    uint64_t       nights;
    uint64_t       city_tax;

    while (list) {
        reservation =
            reservation_manager_get_by_id(manager, single_pool_id_linked_list_get_value(list));
        price_per_night = reservation_get_price_per_night(reservation);
        begin_date      = reservation_get_begin_date(reservation);
        end_date        = reservation_get_end_date(reservation);
        nights          = date_get_day(end_date) - date_get_day(begin_date);
        city_tax        = reservation_get_city_tax(reservation);

        total_spent += price_per_night * nights + (price_per_night * nights * 0.01) * city_tax;

        list = single_pool_id_linked_list_get_next(list);
    }

    return total_spent;
}

/**
 * @brief Executes a query of type 1, where the id points to an ::user_t.
 *
 * @param database Database do get the users and reservations from.
 * @param id       Id to find the user and its data.
 * @param instance Query instance to be executed.
 * @param output   Where to write the query's output to.
 *
 * @retval 0 On success.
 * @retval 1 On failure.
 */
int __execute_q01_user_entity(database_t       *database,
                              char             *id,
                              query_instance_t *instance,
                              FILE             *output) {
    user_manager_t *user_manager = database_get_users(database);
    user_t         *user         = user_manager_get_by_id(user_manager, id);
    if (!user || user_get_account_status(user) == ACCOUNT_STATUS_INACTIVE)
        return 1;

    single_pool_id_linked_list_t *flight_list = user_manager_get_flights_by_id(user_manager, id);
    single_pool_id_linked_list_t *reservation_list =
        user_manager_get_reservations_by_id(user_manager, id);
    uint64_t number_of_flights      = single_pool_id_linked_list_length(flight_list);
    uint64_t number_of_reservations = single_pool_id_linked_list_length(reservation_list);

    reservation_manager_t *reservation_manager = database_get_reservations(database);
    double                 total_spent = __user_total_spent(reservation_list, reservation_manager);

    char sex[SEX_SPRINTF_MIN_BUFFER_SIZE];
    sex_sprintf(sex, user_get_sex(user));

    date_t birth_date = user_get_birth_date(user);
    date_t present_date;
    date_from_values(&present_date, 2023, 10, 1);
    int64_t age = (date_diff(present_date, birth_date)) / 372;

    char country_code[COUNTRY_CODE_SPRINTF_MIN_BUFFER_SIZE];
    country_code_sprintf(country_code, user_get_country_code(user));

    if (query_instance_get_formatted(instance)) {
        fprintf(output,
                "--- 1 ---\nname: %s\nsex: %s\nage: %ld\ncountry_code: %s\n"
                "passport: %s\nnumber_of_flights: %zu\n"
                "number_of_reservations: %zu\ntotal_spent: %.3f\n",
                user_get_const_name(user),
                sex,
                age,
                country_code,
                user_get_const_passport(user),
                number_of_flights,
                number_of_reservations,
                total_spent);
    } else {
        fprintf(output,
                "%s;%s;%ld;%s;%s;%zu;%zu;%.3f\n",
                user_get_const_name(user),
                sex,
                age,
                country_code,
                user_get_const_passport(user),
                number_of_flights,
                number_of_reservations,
                total_spent);
    }

    return 0;
}

/**
 * @brief Executes a query of type 1, where the id points to a ::reservation_t.
 *
 * @param database Database do get the users and reservations from.
 * @param id       Id to find the reservation.
 * @param instance Query instance to be executed.
 * @param output   Where to write the query's output to.
 *
 * @retval 0 On success.
 * @retval 1 On failure.
 */
int __execute_q01_reservation_entity(database_t       *database,
                                     uint64_t         *id,
                                     query_instance_t *instance,
                                     FILE             *output) {
    reservation_manager_t *reservation_manager = database_get_reservations(database);
    reservation_t         *reservation = reservation_manager_get_by_id(reservation_manager, *id);
    if (!reservation)
        return 1;

    const char     *user_id      = reservation_get_const_user_id(reservation);
    user_manager_t *user_manager = database_get_users(database);
    user_t         *user         = user_manager_get_by_id(user_manager, user_id);
    if (user_get_account_status(user) == ACCOUNT_STATUS_INACTIVE)
        return 1;

    date_t begin_date = reservation_get_begin_date(reservation);
    char   begin_date_str[DATE_SPRINTF_MIN_BUFFER_SIZE];
    date_sprintf(begin_date_str, begin_date);

    date_t end_date = reservation_get_end_date(reservation);
    char   end_date_str[DATE_SPRINTF_MIN_BUFFER_SIZE];
    date_sprintf(end_date_str, end_date);

    includes_breakfast_t includes_breakfast = reservation_get_includes_breakfast(reservation);
    char                 includes_breakfast_str[INCLUDES_BREAKFAST_SPRINTF_MIN_BUFFER_SIZE];
    includes_breakfast_sprintf(includes_breakfast_str, includes_breakfast);

    int64_t nights          = date_diff(end_date, begin_date);
    int     price_per_night = reservation_get_price_per_night(reservation);
    int     city_tax        = reservation_get_city_tax(reservation);
    double  total_price = price_per_night * nights + (price_per_night * nights * 0.01) * city_tax;

    if (query_instance_get_formatted(instance)) {
        fprintf(output,
                "--- 1 ---\nhotel_id: HTL%d\nhotel_name: %s\nhotel_stars: %d\n"
                "begin_date: %s\nend_date: %s\nincludes_breakfast: %s\nnights: %ld\n"
                "total_price: %.3f\n",
                reservation_get_hotel_id(reservation),
                reservation_get_const_hotel_name(reservation),
                reservation_get_hotel_stars(reservation),
                begin_date_str,
                end_date_str,
                includes_breakfast_str,
                nights,
                total_price);
    } else {
        fprintf(output,
                "HTL%d;%s;%d;%s;%s;%s;%ld;%.3f\n",
                reservation_get_hotel_id(reservation),
                reservation_get_const_hotel_name(reservation),
                reservation_get_hotel_stars(reservation),
                begin_date_str,
                end_date_str,
                includes_breakfast_str,
                nights,
                total_price);
    }

    return 0;
}

/**
 * @brief Executes a query of type 1, where the id points to a ::flight_t.
 *
 * @param database Database do get the flights from.
 * @param id       Id to find the flight.
 * @param instance Query instance to be executed.
 * @param output   Where to write the query's output to.
 *
 * @retval 0 On success.
 * @retval 1 On failure.
 */
int __execute_q01_flight_entity(database_t       *database,
                                uint64_t         *id,
                                query_instance_t *instance,
                                FILE             *output) {
    flight_manager_t *flight_manager = database_get_flights(database);
    flight_t         *flight         = flight_manager_get_by_id(flight_manager, *id);
    if (!flight)
        return 1;

    airport_code_t origin_code = flight_get_origin(flight);
    char           origin_airport[AIRPORT_CODE_SPRINTF_MIN_BUFFER_SIZE];
    airport_code_sprintf(origin_airport, origin_code);

    airport_code_t destination_code = flight_get_destination(flight);
    char           destination_airport[AIRPORT_CODE_SPRINTF_MIN_BUFFER_SIZE];
    airport_code_sprintf(destination_airport, destination_code);

    date_and_time_t scheduled_departure_date = flight_get_schedule_departure_date(flight);
    char            scheduled_departure_str[DATE_AND_TIME_SPRINTF_MIN_BUFFER_SIZE];
    date_and_time_sprintf(scheduled_departure_str, scheduled_departure_date);

    date_and_time_t scheduled_arrival_date = flight_get_schedule_arrival_date(flight);
    char            scheduled_arrival_str[DATE_AND_TIME_SPRINTF_MIN_BUFFER_SIZE];
    date_and_time_sprintf(scheduled_arrival_str, scheduled_arrival_date);

    date_and_time_t real_departure_date = flight_get_real_departure_date(flight);
    int64_t         delay = date_and_time_diff(real_departure_date, scheduled_departure_date);

    if (query_instance_get_formatted(instance)) {
        fprintf(output,
                "--- 1 ---\nairline: %s\nplane_model: %s\norigin: %s\n"
                "destination: %s\nschedule_departure_date: %s\nschedule_arrival_date: %s\n"
                "passengers: %d\ndelay: %zu\n",
                flight_get_const_airline(flight),
                flight_get_const_plane_model(flight),
                origin_airport,
                destination_airport,
                scheduled_departure_str,
                scheduled_arrival_str,
                flight_get_number_of_passengers(flight),
                delay);
    } else {
        fprintf(output,
                "%s;%s;%s;%s;%s;%s;%d;%zu\n",
                flight_get_const_airline(flight),
                flight_get_const_plane_model(flight),
                origin_airport,
                destination_airport,
                scheduled_departure_str,
                scheduled_arrival_str,
                flight_get_number_of_passengers(flight),
                delay);
    }

    return 0;
}

/**
 * @brief Executes a query of type 1.
 *
 * @param database   Database where to get users/reservations/flights from
 * @param statistics `NULL`, as this query does not generate statistical data.
 * @param instance   Query instance to be executed.
 * @param output     Where to write the query's output to.
 *
 * @retval 0 On success.
 * @retval 1 On failure.
 */
int __q01_execute(database_t       *database,
                  void             *statistics,
                  query_instance_t *instance,
                  FILE             *output) {
    (void) statistics;
    parse_arguments_helper_t *arguments = query_instance_get_argument_data(instance);
    void                     *id;
    int                       ret;

    switch (arguments->id_entity) {
        case ID_ENTITY_USER:
            id  = arguments->parsed_id;
            ret = __execute_q01_user_entity(database, id, instance, output);
            if (ret)
                return 1;
            break;
        case ID_ENTITY_RESERVATION:
            id  = arguments->parsed_id;
            ret = __execute_q01_reservation_entity(database, id, instance, output);
            if (ret)
                return 1;
            break;
        case ID_ENTITY_FLIGHT:
            id  = arguments->parsed_id;
            ret = __execute_q01_flight_entity(database, id, instance, output);
            if (ret)
                return 1;
            break;
        default:
            return 1;
            break;
    }

    return 0;
}

query_type_t *q01_create(void) {
    return query_type_create(__q01_parse_arguments,
                             __q01_free_query_instance_argument_data,
                             NULL,
                             NULL,
                             __q01_execute);
}
