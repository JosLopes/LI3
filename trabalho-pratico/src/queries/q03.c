/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  q03.c
 * @brief Implementation of methods in include/queries/q03.h
 */

#include <stdio.h>

#include "queries/q03.h"
#include "queries/query_instance.h"
#include "utils/glib/GConstKeyHashTable.h"

/**
 * @brief   Parses arguments for a query of type 3.
 * @details Asserts that there's only one argument, a hotel identifier.
 *
 * @param argc Number of arguments.
 * @param argv Values of the arguments.
 *
 * @return `NULL` on parsing failure, an hotel ID encoded as a pointer otherwise otherwise.
 */
void *__q03_parse_arguments(size_t argc, char *const argv[argc]) {
    if (argc != 1)
        return NULL;

    hotel_id_t id;
    return hotel_id_from_string(&id, argv[0]) ? NULL : GUINT_TO_POINTER(id);
}

/**
 * @brief  Creates a deep clone of the value returned by ::__q03_parse_arguments.
 * @param  args_data Non-`NULL` value returned by ::__q03_parse_arguments (a hotel ID encoded as a
 *         pointer).
 * @return A deep copy of @p args_data.
 */
void *__q03_clone_arguments(const void *args_data) {
    return (void *) args_data; /* Const cast acceptable - it's an just an integer */
}

/**
 * @brief   Frees data generated by ::__q03_parse_arguments.
 * @details Does nothing, as @p args_data is just an integer encoded as a pointer.
 * @param   args_data Data generated by ::__q03_parse_arguments.
 */
void __q03_free_arguments(void *args_data) {
    (void) args_data;
}

/**
 * @struct q03_average_t
 * @brief  Data structure containing the for calculating a flying average.
 *
 * @var q03_average_t::sum
 *     @brief Sum of all ratings checked until now.
 * @var q03_average_t::count
 *     @brief Number of reservations checked until now.
 */
typedef struct {
    uint64_t sum;
    size_t   count;
} q03_average_t;

/**
 * @brief   A method called for each reservation, to consider it in averages being calculated.
 * @details An auxiliary method for ::__q03_generate_statistics.
 *
 * @param user_data   ::GConstKeyHashTable between hotel identifiers (as pointers) and pointers to
 *                    ::q03_average_t.
 * @param reservation Reservation being processed.
 *
 * @retval 0 Always successful.
 */
int __q03_generate_statistics_foreach_reservation(void                *user_data,
                                                  const reservation_t *reservation) {
    GConstKeyHashTable *const ratings_averages = user_data;

    const hotel_id_t     hotel_id = reservation_get_hotel_id(reservation);
    q03_average_t *const avg =
        g_const_key_hash_table_lookup(ratings_averages, GUINT_TO_POINTER(hotel_id));
    if (!avg)
        return 0;

    avg->sum += reservation_get_rating(reservation);
    avg->count++;
    return 0;
}

/**
 * @brief Generates statistical data for queries of type 3.
 *
 * @param database  Database, to iterate through reservations.
 * @param n         Number of query instances that need to be executed.
 * @param instances Query instances that need to be executed.
 *
 * @return A ::GConstKeyHashTable that associates hotel identifiers with ::q03_average_t for those
 *         hotels, or `NULL` on allocation failure.
 */
void *__q03_generate_statistics(const database_t             *database,
                                size_t                        n,
                                const query_instance_t *const instances[n]) {

    GConstKeyHashTable *const ratings_averages =
        g_const_key_hash_table_new_full(g_direct_hash, g_direct_equal, free);

    for (size_t i = 0; i < n; ++i) {
        q03_average_t *const average = malloc(sizeof(q03_average_t));
        if (!average) {
            g_const_key_hash_table_unref(ratings_averages);
            return NULL;
        }

        average->sum   = 0;
        average->count = 0;
        g_const_key_hash_table_insert(ratings_averages,
                                      query_instance_get_argument_data(instances[i]),
                                      average);
    }

    reservation_manager_iter(database_get_reservations(database),
                             __q03_generate_statistics_foreach_reservation,
                             ratings_averages);
    return ratings_averages;
}

/**
 * @brief Method called to execute a query of type 3.
 *
 * @param database   Database to get data from (not used, as all data is collected in
 *                   ::__q03_generate_statistics).
 * @param statistics Statistical data generated by ::__q03_generate_statistics.
 * @param instance   Query instance to be executed.
 * @param output     Where to write the query's result to.
 *
 * @retval 0 Success.
 * @retval 1 Fatal failure (should, in principle, be unreachable).
 */
int __q03_execute(const database_t       *database,
                  const void             *statistics,
                  const query_instance_t *instance,
                  query_writer_t         *output) {
    (void) database;

    const GConstKeyHashTable *const ratings_averages = statistics;
    const hotel_id_t hotel_id = GPOINTER_TO_UINT(query_instance_get_argument_data(instance));

    const q03_average_t *const avg =
        g_const_key_hash_table_const_lookup(ratings_averages, GUINT_TO_POINTER(hotel_id));
    if (!avg) {
        fprintf(stderr, "Bad statistical data in query 3! This should not happen!\n");
        return 1;
    }

    query_writer_write_new_object(output);
    query_writer_write_new_field(output, "rating", "%.3f", (double) avg->sum / (double) avg->count);
    return 0;
}

query_type_t *q03_create(void) {
    return query_type_create(3,
                             __q03_parse_arguments,
                             __q03_clone_arguments,
                             __q03_free_arguments,
                             __q03_generate_statistics,
                             (query_type_free_statistics_callback_t) g_const_key_hash_table_unref,
                             __q03_execute);
}
