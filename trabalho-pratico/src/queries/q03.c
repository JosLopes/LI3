/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  q03.c
 * @brief Implementation of methods in include/queries/q03.h
 */

#include <glib.h>
#include <stdio.h>
#include <stdlib.h>

#include "queries/qplaceholder.h"
#include "queries/query_instance.h"
#include "utils/int_utils.h"

/**
 * @brief   Parses arguments for the third query.
 * @details Asserts that there's only one argument, an hotel identifier.
 *
 * @param argv Values of the arguments.
 * @param argc Number of arguments.
 *
 * @return `NULL` on failure, a pointer to a hotel ID otherwise.
 */
void *__q03_parse_arguments(char **argv, size_t argc) {
    if (argc != 1)
        return NULL;

    hotel_id_t id;
    int        retval = hotel_id_from_string(&id, argv[0]);
    if (retval == 0) {
        hotel_id_t *id_ptr = malloc(sizeof(hotel_id_t));
        if (id_ptr)
            *id_ptr = id;

        return id_ptr;
    } else if (retval == 2) {
        /* TODO - have a way of communicating this failure */
        /* fprintf(stderr,
                  "Hotel ID \"%s\" not if format HTLXXXXX. This isn't supported by our program!\n",
                  token);*/
    }
    return NULL;
}

/**
 * @struct q03_average_t
 * @brief Data structure containing the fields needed to calculate a flying average.
 *
 * @var q03_average_t::sum
 *     @brief Sum of all ratings checked until now.
 * @var q03_average_t::count
 *     @brief Number of reservations checked until now.
 */
typedef struct {
    uint64_t sum;
    size_t   count;
} q03_average_t;

/**
 * @brief   A method called for each reservation, to consider it in averages being calculated.
 * @details An auxiliary method for ::__q03_generate_statistics.
 *
 * @param user_data   `GHashTable` between hotel identifiers and pointers to ::q03_average_t.
 * @param reservation Reservation being processed.
 *
 * @retval 0 Always successful
 */
int __q03_generate_statistics_foreach_reservation(void                *user_data,
                                                  const reservation_t *reservation) {
    GHashTable *ratings_averages = (GHashTable *) user_data;

    hotel_id_t     hotel_id = reservation_get_hotel_id(reservation);
    q03_average_t *avg      = g_hash_table_lookup(ratings_averages, GUINT_TO_POINTER(hotel_id));
    if (!avg)
        return 0;

    uint8_t rating = reservation_get_rating(reservation);
    avg->sum += rating;
    avg->count++;
    return 0;
}

/**
 * @brief Generates statistical data for queries of type 3.
 *
 * @param database  Database, to iterate through reservations.
 * @param instances Query instances that will need to be executed.
 * @param n         Number of query instances that will need to be executed.
 *
 * @return A `GHashTable` that associates hotel identifiers with ::q03_average_t for those hotels,
 *         or `NULL` on failure.
 */
void *__q03_generate_statistics(database_t *database, query_instance_t *instances, size_t n) {

    GHashTable *ratings_averages =
        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) free);

    for (size_t i = 0; i < n; ++i) {
        hotel_id_t hotel_id = *(hotel_id_t *) query_instance_get_argument_data(instances);

        q03_average_t *average = malloc(sizeof(q03_average_t));
        if (!average) {
            g_hash_table_unref(ratings_averages);
            return NULL;
        }

        average->sum   = 0;
        average->count = 0;
        g_hash_table_insert(ratings_averages, GUINT_TO_POINTER(hotel_id), average);

        instances = (query_instance_t *) ((uint8_t *) instances + query_instance_sizeof());
    }

    reservation_manager_iter(database_get_reservations(database),
                             __q03_generate_statistics_foreach_reservation,
                             ratings_averages);
    return ratings_averages;
}

/**
 * @brief Method called to execute a query of type 3.
 *
 * @param database   Database to get data from (not used, as all data is collected in
 *                   ::__q03_generate_statistics).
 * @param statistics Statistical data generated by ::__q03_generate_statistics.
 * @param instance   Query instance to be executed.
 * @param output     Where to write the query's result to.
 *
 * @retval 0 Success
 * @retval 1 Fatal failure (will only happen if a cosmic ray flips some bit in your memory).
 */
int __q03_execute(database_t       *database,
                  void             *statistics,
                  query_instance_t *instance,
                  query_writer_t   *output) {
    (void) database;

    GHashTable *ratings_averages = (GHashTable *) statistics;
    hotel_id_t  hotel_id         = *(hotel_id_t *) query_instance_get_argument_data(instance);

    q03_average_t *avg = g_hash_table_lookup(ratings_averages, GUINT_TO_POINTER(hotel_id));
    if (!avg) {
        fprintf(stderr, "Bad statistical data in query 3! This should not happen!\n");
        return 1;
    }

    query_writer_write_new_object(output);
    query_writer_write_new_field(output, "rating", "%.3f", (double) avg->sum / (double) avg->count);
    return 0;
}

query_type_t *q03_create(void) {
    return query_type_create(__q03_parse_arguments,
                             free,
                             __q03_generate_statistics,
                             (query_type_free_statistics_callback_t) g_hash_table_unref,
                             __q03_execute);
}
