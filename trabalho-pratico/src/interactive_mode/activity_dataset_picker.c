/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file  activity_dataset_picker.c
 * @brief Implementation of methods in activity_dataset_picker.h
 *
 * ### Examples
 * See [the header file's documentation](@ref activity_dataset_picker_examples).
 */

/** @cond FALSE */
#define _XOPEN_SOURCE_EXTENDED
/** @endcond */

#include <dirent.h>
#include <glib.h>
#include <limits.h>
#include <ncurses.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "interactive_mode/activity_dataset_picker.h"
#include "interactive_mode/ncurses_utils.h"
#include "utils/int_utils.h"

/**
 * @struct activity_dataset_picker_data_t
 * @brief  Data in a dataset picker TUI activity.
 */
typedef struct {
    GPtrArray *dir_list;
} activity_dataset_picker_data_t;

/**
 * @brief Responds to user input in a dataset activity.
 *
 * @param activity_data Pointer to a ::activity_dataset_picker_data_t.
 * @param key           Key that was pressed. May be an ncurses `KEY_*` value.
 * @param is_key_code   If the pressed key is not a character, but an ncurses `KEY_*` value.
 *
 * @retval 0 The user didn't quit the dataset picker; continue.
 * @retval 1 The user quit the directory picker, either by choosing the dataset, wanting to move to
 *           another directory, wanting to write out the path of a new directory to visit, or by
 *           pressing escape and quitting the directory picker altogether.
 */
int __activity_dataset_picker_keypress(void *activity_data, wint_t key, int is_key_code) {
    activity_dataset_picker_data_t *picker = (activity_dataset_picker_data_t *) activity_data;

    (void) picker;

    if (!is_key_code && key == '\x1b')
        return 1;
    return 0;
}

/**
 * @brief Renders a dataset picker activity.
 * @param activity_data Pointer to a ::activity_dataset_picker_data_t.
 * @retval 0 Always, to continue running this activity.
 */
int __activity_dataset_picker_render(void *activity_data) {
    activity_dataset_picker_data_t *picker = (activity_dataset_picker_data_t *) activity_data;

    for (size_t i = 0; i < picker->dir_list->len; ++i) {
        printw("%s\n", (char *) g_ptr_array_index(picker->dir_list, i));
    }

    return 0;
}

/**
 * @brief Frees a textbox activity, generated by ::__activity_dataset_picker_create.
 * @param activity_data Pointer to a ::activity_dataset_picker_data_t.
 */
void __activity_dataset_picker_free_data(void *activity_data) {
    activity_dataset_picker_data_t *picker = (activity_dataset_picker_data_t *) activity_data;
    (void) picker;

    for (size_t i = 0; i < picker->dir_list->len; ++i)
        free(g_ptr_array_index(picker->dir_list, i));
    g_ptr_array_unref(picker->dir_list);

    free(picker);
}

/* TODO - docs */
gint __activity_dataset_picker_create_sort_strings(gconstpointer a, gconstpointer b) {
    const char *string_a = * (const char **) a;
    const char *string_b = * (const char **) b;
    return strcmp(string_a, string_b);
}

/**
 * @brief  Creates an ::activity_t for a dataset picker.
 * @param  path Path of the directory to list.
 * @return An ::activity_t for a dataset picker, that must be deleted using ::activity_free.
 *         `NULL` is also a possibility, when an allocation failure occurs.
 */
activity_t *__activity_dataset_picker_create(const char *path) {
    (void) path;

    activity_dataset_picker_data_t *activity_data = malloc(sizeof(activity_dataset_picker_data_t));
    if (!activity_data)
        return NULL;

    activity_data->dir_list = g_ptr_array_new();

    /* Load list of directories */
    DIR *dir = opendir(path);
    if (!dir) {
        /* TODO - replace with message box */
        fputs("Failed to get current working directory!\n", stderr);

        g_ptr_array_unref(activity_data->dir_list);
        free(activity_data);
        return NULL;
    }

    struct dirent *ent;
    while ((ent = readdir(dir)) != NULL) {
        if (*ent->d_name != '.' || strcmp(ent->d_name, "..") == 0) {
            g_ptr_array_add(activity_data->dir_list, strdup(ent->d_name));
        }
    }
    closedir(dir);

    g_ptr_array_sort(activity_data->dir_list, __activity_dataset_picker_create_sort_strings);

    return activity_create(__activity_dataset_picker_keypress,
                           __activity_dataset_picker_render,
                           __activity_dataset_picker_free_data,
                           activity_data);
}

char *activity_dataset_picker_run(void) {
    char pwd[PATH_MAX];
    if (!getcwd(pwd, PATH_MAX)) {
        /* TODO - replace by message box */
        fputs("Failed to get current working directory!\n", stderr);
        return NULL;
    }

    activity_t *activity = __activity_dataset_picker_create(pwd);
    if (!activity)
        return NULL;

    activity_run(activity);

    activity_free(activity);
    return NULL;
}
