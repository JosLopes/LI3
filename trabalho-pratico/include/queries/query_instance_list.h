/*
 * Copyright 2023 Humberto Gomes, José Lopes, José Matos
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file    query_instance_list.h
 * @brief   A list of ::query_instance_t ordered by query type.
 * @details This could be, for example, a list of queries coming from a file.
 *
 * @anchor query_instance_list_examples
 * ### Examples
 *
 * Usually, a ::query_instance_list_t is generated by a
 * [query file parser](@ref query_file_parser.h). A good example of that can be seen in
 * batch_mode.c. However, if you'd like to manually generate it, here's how you'd do it:
 *
 * - Create it with ::query_instance_list_create:
 *
 * ```c
 * query_instance_list_t *list = query_instance_list_create();
 * if (!list) {
 *     fputs("Failure to allocate query list!\n", stderr);
 *     return NULL;
 * }
 * ```
 *
 * - Add query instances to it, using ::query_instance_list_add.
 *
 * - When done using the list, free it with ::query_instance_list_free, in case you also own the
 *   queries you added to list, or using ::query_instance_list_free_no_internals if you don't.
 *
 * There are two types of list iterations. Before any of these iterations, the list will be sorted
 * by query type order.
 *
 * - Query by query iteration using ::query_instance_list_iter. This is trivial, though an example
 *   can be found in batch_mode.c, to open all files to write query outputs in.
 *
 * - Iteration by query type using ::query_instance_list_iter_types, where a callback is called
 *   for each set of queries of the same type. Here's an example. Suppose we have the following
 *   file with queries (consider the first number to be the line number in the file):
 *
 *   ```text
 *   1 | 1  Alice
 *   2 | 2F Bob
 *   3 | 1F Carol
 *   4 | 2  Dan
 *   5 | 3  Erin
 *   ```
 *
 *   This will be sorted, becoming:
 *
 *   ```text
 *   1 | 1  Alice
 *   3 | 1F Carol
 *   2 | 2F Bob
 *   4 | 2  Dan
 *   5 | 3  Erin
 *   ```
 *
 *   Then, three callbacks will be performed: one for Alice and Carol, another one for Bob and Dan,
 *   and finally, one for Erin.
 */

#ifndef QUERY_INSTANCE_LIST_H
#define QUERY_INSTANCE_LIST_H

#include "queries/query_instance.h"

/** @brief A list of ::query_instance_t. */
typedef struct query_instance_list query_instance_list_t;

/**
 * @brief Method called for every set of query instances of the same type, in
 *        ::query_instance_list_iter_types.
 *
 * @param user_data Pointer, kept from call to call, so that this callback can modify the program's
 *                  state.
 * @param instances All query instances of the same type.
 * @param n         Number of instances in @p instances. It's guaranteed that there'll be no empty
 *                  sets.
 *
 * @return `0` on success, another value for immediate termination of iteration.
 */
typedef int (*query_instance_list_iter_types_callback)(void                          *user_data,
                                                       const query_instance_t *const *instances,
                                                       size_t                         n);

/**
 * @brief Method called for every query in a query list, used by ::query_instance_list_iter.
 *
 * @param user_data Pointer, kept from call to call, so that this callback can modify the program's
 *                  state.
 * @param instance  Query instance.
 *
 * @return `0` on success, another value for immediate termination of iteration.
 */
typedef int (*query_instance_list_iter_callback)(void *user_data, const query_instance_t *instance);

/**
 * @brief   Creates an empty list of ::query_instance_t.
 * @details This value must be `free`'d with ::query_instance_list_free.
 * @return  A new ::query_instance_list_t, or `NULL` on failure.
 *
 * #### Examples
 * See [the header file's documentation](@ref query_instance_list_examples).
 */
query_instance_list_t *query_instance_list_create(void);

/**
 * @brief Creates a deep copy of a list of query instances.
 *
 * @param list            List to be cloned.
 * @param query_type_list List of supported queries (to know how to duplicate `argument_data` in
 *                        queries in @p list).
 */
query_instance_list_t *query_instance_list_clone(const query_instance_list_t *list,
                                                 const query_type_list_t     *query_type_list);

/**
 * @brief Copies a query instance into a list of query instances.
 *
 * @param list            List of query instances to add @p query to.
 * @param query           Query instance to be added to @p list.
 * @param query_type_list List of supported queries (to know how to duplicate `argument_data` in @p
 *                        query).
 */
void query_instance_list_add(query_instance_list_t   *list,
                             const query_instance_t  *query,
                             const query_type_list_t *query_type_list);

/**
 * @brief Iterates over every set of queries of each type.
 *
 * @param list      List of query instances. Cannot be constant, as sorting may occur.
 * @param callback  Callback called for every set of queries of each type.
 * @param user_data Value passed to @p callback, so that it can modify the program's state.
 *
 * @return The last value returned by @p callback (will always be `0` on success).
 *
 * #### Examples
 * See [the header file's documentation](@ref query_instance_list_examples).
 */
int query_instance_list_iter_types(query_instance_list_t                  *list,
                                   query_instance_list_iter_types_callback callback,
                                   void                                   *user_data);

/**
 * @brief Iterates over every query in a query instance list.
 *
 * @param list      List of query instances. Cannot be constant, as sorting may occur.
 * @param callback  Callback called for every set of queries of each type.
 * @param user_data Value passed to @p callback, so that it can modify the program's state.
 *
 * @return The last value returned by @p callback (will always be `0` on success).
 */
int query_instance_list_iter(query_instance_list_t            *list,
                             query_instance_list_iter_callback callback,
                             void                             *user_data);

/**
 * @brief  Gets the length of a ::query_instance_list_t.
 * @param  list List to get the length from.
 * @return The length of @p list.
 */
size_t query_instance_list_get_length(const query_instance_list_t *list);

/**
 * @brief Frees memory allocated by ::query_instance_list_create.
 *
 * @param list List allocated by ::query_instance_list_create.
 * @param query_type_list List of supported queries (to know how to free `argument_data` in each
 *                        query instance in the list).
 */
void query_instance_list_free(query_instance_list_t   *list,
                              const query_type_list_t *query_type_list);

#endif
